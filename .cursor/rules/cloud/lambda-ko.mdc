---
# âš ï¸ ì´ íŒŒì¼ì€ AIê°€ ì½ì§€ ì•ŠìŠµë‹ˆë‹¤ (Human Reference Only)
# AIëŠ” lambda.mdc (ì˜ë¬¸íŒ)ë§Œ ì°¸ì¡°í•©ë‹ˆë‹¤
---

# âš¡ AWS Lambda ê°œë°œ ê°€ì´ë“œë¼ì¸

## ì—­í•  ì •ì˜
ë‹¹ì‹ ì€ AGROUNDSì˜ AWS Lambda í•¨ìˆ˜ë¥¼ ê°œë°œí•˜ê³  ìœ ì§€ë³´ìˆ˜í•  ì±…ì„ì´ ìˆìœ¼ë©°, íŠ¹íˆ í”Œë ˆì´ì–´ ë¶„ì„ê³¼ ê°™ì€ ë¹„ë™ê¸° ë°ì´í„° ì²˜ë¦¬ ì‘ì—…ì— ì§‘ì¤‘í•©ë‹ˆë‹¤.

---

## ğŸš¨ Lambda ê°œë°œ ì›ì¹™

### âŒ ê¸ˆì§€ ì‚¬í•­
1. **ë™ê¸° ì²˜ë¦¬ ê¸ˆì§€** - LambdaëŠ” ë¹„ë™ê¸° ì‘ì—…ì—ë§Œ ì‚¬ìš©
2. **ìƒíƒœ ìœ ì§€ ê¸ˆì§€** - LambdaëŠ” ë¬´ìƒíƒœ(stateless)
3. **ë¡œì»¬ íŒŒì¼ ì˜ì†ì„± ê¸ˆì§€** - /tmpë§Œ ì‚¬ìš©, ì‹¤í–‰ í›„ ì‚­ì œë¨
4. **í•˜ë“œì½”ë”©ëœ ìê²©ì¦ëª… ê¸ˆì§€** - í•­ìƒ í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš©
5. **ë¬´í•œ ë£¨í”„ ê¸ˆì§€** - íƒ€ì„ì•„ì›ƒ ì œí•œ ì¤€ìˆ˜

### âœ… í•„ìˆ˜ ìš”êµ¬ì‚¬í•­
1. **/tmp ë””ë ‰í† ë¦¬ ì‚¬ìš©** - ì„ì‹œ íŒŒì¼ë§Œ
2. **íƒ€ì„ì•„ì›ƒ êµ¬í˜„** - ì ì ˆí•œ íƒ€ì„ì•„ì›ƒ ì œí•œ ì„¤ì •
3. **ëª¨ë“  ê²ƒ ë¡œê¹…** - CloudWatch ë¡œê¹… ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©
4. **ìš°ì•„í•œ ì—ëŸ¬ ì²˜ë¦¬** - ì ì ˆí•œ ì—ëŸ¬ ì‘ë‹µ ë°˜í™˜
5. **ë©”ëª¨ë¦¬ ìµœì í™”** - ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”

---

## ğŸ“‚ Lambda í•¨ìˆ˜ êµ¬ì¡°

### AGROUNDS Lambda: player_anal

**ìœ„ì¹˜**: `/home/ubuntu/agrounds/mysite/lambda/player_anal/`

**ëª©ì **: GPS ë°ì´í„° ì²˜ë¦¬ ë° í”Œë ˆì´ì–´ ì„±ëŠ¥ ë¶„ì„ ìƒì„±

```
lambda/player_anal/
â”œâ”€â”€ main.py              # Lambda í•¸ë“¤ëŸ¬ (ì§„ì…ì )
â”œâ”€â”€ anal_cal.py          # ë¶„ì„ ê³„ì‚°
â”œâ”€â”€ summarize.py         # ë°ì´í„° ìš”ì•½
â”œâ”€â”€ gpt.py               # GPT API í†µí•©
â”œâ”€â”€ deploy_lambda.py     # ë°°í¬ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ check_lambda_logs.py # ë¡œê·¸ ëª¨ë‹ˆí„°ë§
â””â”€â”€ README.md            # ë¬¸ì„œ
```

---

## ğŸ”„ ì²˜ë¦¬ í”Œë¡œìš°

```
1. íŠ¸ë¦¬ê±° (Django API)
   â†’ Lambdaë¡œ POST ìš”ì²­

2. GPS ë¶„ì„ (30-60ì´ˆ)
   â†’ S3ì—ì„œ GPS ë°ì´í„° ë‹¤ìš´ë¡œë“œ
   â†’ anal_cal.player_anal() ì‹¤í–‰
   â†’ 4ê°œ ì¿¼í„° ì²˜ë¦¬
   â†’ PlayerAnal í…Œì´ë¸”ì— ì €ì¥

3. AI ìš”ì•½ (20-40ì´ˆ)
   â†’ ì¿¼í„° ë°ì´í„° ìš”ì•½ (summarize.py)
   â†’ GPT-4 API í˜¸ì¶œ (gpt.py)
   â†’ í•µì‹¬ í¬ì¸íŠ¸ 5ê°œ ì¶”ì¶œ
   â†’ PlayerAi í…Œì´ë¸”ì— ì €ì¥

ì´ ì†Œìš” ì‹œê°„: 1-2ë¶„
```

---

## ğŸ¯ Lambda í•¸ë“¤ëŸ¬ íŒ¨í„´

### main.py êµ¬ì¡°
```python
import os
import json
import traceback
import boto3
import pymysql
from datetime import datetime

# ìƒìˆ˜
DEFAULT_HZ = 10
API_TIMEOUT_SECONDS = 10
DEFAULT_PLAYER_TYPE = 'amateur'

# AWS í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
s3 = boto3.client('s3')

def lambda_handler(event, context):
    """
    í”Œë ˆì´ì–´ ë¶„ì„ì„ ìœ„í•œ ë©”ì¸ Lambda í•¸ë“¤ëŸ¬
    
    Args:
        event: Lambda ì´ë²¤íŠ¸ ê°ì²´
            {
                "match_code": "m_123",
                "ground_code": "g_456",
                "s3_key": "uploads/gps_data.csv",
                "player_type": "amateur"
            }
        context: Lambda ì»¨í…ìŠ¤íŠ¸ ê°ì²´
        
    Returns:
        {
            "statusCode": 200,
            "body": json.dumps({"message": "Success", "match_code": "m_123"})
        }
    """
    try:
        # 1. íŒŒë¼ë¯¸í„° ì¶”ì¶œ
        match_code = event.get('match_code')
        ground_code = event.get('ground_code')
        s3_key = event.get('s3_key')
        
        # 2. í•„ìˆ˜ íŒŒë¼ë¯¸í„° ê²€ì¦
        if not all([match_code, ground_code, s3_key]):
            raise ValueError("Missing required parameters")
        
        # 3. S3ì—ì„œ GPS ë°ì´í„° ë‹¤ìš´ë¡œë“œ
        local_file = download_from_s3(
            bucket=os.environ['S3_BUCKET_NAME'],
            key=s3_key,
            local_name='gps_data.csv'
        )
        
        # 4. ë¶„ì„ ì²˜ë¦¬
        results = process_player_analysis(
            match_code=match_code,
            ground_code=ground_code,
            gps_file=local_file
        )
        
        # 5. ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
        save_analysis_results(match_code, results)
        
        # 6. AI ìš”ì•½ ìƒì„±
        ai_summary = generate_ai_summary(match_code, results)
        save_ai_summary(match_code, ai_summary)
        
        # 7. ê²½ê¸° ìƒíƒœ ì—…ë°ì´íŠ¸
        update_match_status(match_code, 'complete')
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'Analysis completed successfully',
                'match_code': match_code,
                'quarters_processed': len(results)
            })
        }
        
    except Exception as e:
        # ì—ëŸ¬ ë¡œê¹…
        print(f"ERROR: {str(e)}")
        print(traceback.format_exc())
        
        # ê²½ê¸° ìƒíƒœë¥¼ ì‹¤íŒ¨ë¡œ ì—…ë°ì´íŠ¸
        if match_code:
            update_match_status(match_code, 'anal_fail')
        
        return {
            'statusCode': 500,
            'body': json.dumps({
                'error': str(e),
                'match_code': match_code
            })
        }
    finally:
        # /tmp ë””ë ‰í† ë¦¬ ì •ë¦¬
        cleanup_tmp_files()

def download_from_s3(bucket, key, local_name):
    """S3ì—ì„œ /tmpë¡œ íŒŒì¼ ë‹¤ìš´ë¡œë“œ"""
    path = f"/tmp/{local_name}"
    s3.download_file(bucket, key, path)
    return path

def cleanup_tmp_files():
    """/tmp ë””ë ‰í† ë¦¬ ì •ë¦¬"""
    import shutil
    for filename in os.listdir('/tmp'):
        file_path = os.path.join('/tmp', filename)
        try:
            if os.path.isfile(file_path):
                os.unlink(file_path)
            elif os.path.isdir(file_path):
                shutil.rmtree(file_path)
        except Exception as e:
            print(f"Failed to delete {file_path}: {e}")
```

---

## âš™ï¸ Lambda ì„¤ì •

### í•„ìˆ˜ í™˜ê²½ ë³€ìˆ˜
```bash
# ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
DB_HOST=agroundrds.c4mjyhzyjllp.ap-northeast-2.rds.amazonaws.com
DB_USER=ground
DB_PASSWORD=***  # í™˜ê²½ì—ì„œ
DB_NAME=agroundsDB

# AWS S3
S3_BUCKET_NAME=aground-gps
AWS_REGION=ap-northeast-2

# ì™¸ë¶€ API
GPT_API_KEY=sk-proj-***  # OpenAI API í‚¤
DJANGO_API_URL=https://agrounds.com

# ì²˜ë¦¬ ì„¤ì •
DEFAULT_HZ=10
PLAYER_TYPE=amateur
```

### Lambda ì„¤ì • (ê¶Œì¥)
```
í•¨ìˆ˜ ì´ë¦„: Agrounds_player_anal
ëŸ°íƒ€ì„: Python 3.12
í•¸ë“¤ëŸ¬: main.lambda_handler
íƒ€ì„ì•„ì›ƒ: 300ì´ˆ (5ë¶„)
ë©”ëª¨ë¦¬: 1024 MB
ì•„í‚¤í…ì²˜: x86_64
ë¦¬ì „: ap-northeast-2 (ì„œìš¸)
```

### Lambda Layers
```
Layer 1: agrounds-openai
  - openai
  - tiktoken
  - GPT í†µí•©ì„ ìœ„í•œ ì˜ì¡´ì„±

Layer 2: agrounds-data-processing (í•„ìš”ì‹œ)
  - pandas
  - numpy
  - scipy
```

---

## ğŸš€ ë°°í¬ í”„ë¡œì„¸ìŠ¤

### 1. ìŠ¤í¬ë¦½íŠ¸ë¡œ ë°°í¬
```bash
cd /home/ubuntu/agrounds/mysite/lambda/player_anal
python3 deploy_lambda.py
```

**deploy_lambda.pyê°€ í•˜ëŠ” ì¼**:
1. âœ… main.py, anal_cal.py, summarize.py, gpt.py íŒ¨í‚¤ì§•
2. âœ… ZIP íŒŒì¼ ìƒì„±
3. âœ… Lambda í•¨ìˆ˜ ì½”ë“œ ì—…ë°ì´íŠ¸
4. âœ… ë°°í¬ ê²€ì¦

### 2. ìˆ˜ë™ ë°°í¬ (ëŒ€ì•ˆ)
```bash
# ë°°í¬ íŒ¨í‚¤ì§€ ìƒì„±
cd /home/ubuntu/agrounds/mysite/lambda/player_anal
zip -r lambda_function.zip main.py anal_cal.py summarize.py gpt.py

# Lambdaì— ì—…ë¡œë“œ
aws lambda update-function-code \
    --function-name Agrounds_player_anal \
    --zip-file fileb://lambda_function.zip \
    --region ap-northeast-2
```

### 3. Lambda Layer ìƒì„±/ì—…ë°ì´íŠ¸ (ìµœì´ˆ 1íšŒ)
```bash
# Layer íŒ¨í‚¤ì§€ ìƒì„±
mkdir -p python/lib/python3.12/site-packages
pip install openai tiktoken -t python/lib/python3.12/site-packages
zip -r openai_layer.zip python

# Layer ë°°í¬
aws lambda publish-layer-version \
    --layer-name agrounds-openai \
    --description 'OpenAI and tiktoken for player analysis' \
    --zip-file fileb://openai_layer.zip \
    --compatible-runtimes python3.12 \
    --compatible-architectures x86_64 \
    --region ap-northeast-2

# í•¨ìˆ˜ì— Layer ì—°ê²°
aws lambda update-function-configuration \
    --function-name Agrounds_player_anal \
    --layers arn:aws:lambda:ap-northeast-2:ACCOUNT_ID:layer:agrounds-openai:VERSION
```

---

## ğŸ“Š ë°ì´í„°ë² ì´ìŠ¤ í†µí•©

### PyMySQL ì—°ê²° íŒ¨í„´
```python
import pymysql
import os

def get_db_connection():
    """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒì„±"""
    return pymysql.connect(
        host=os.environ['DB_HOST'],
        user=os.environ['DB_USER'],
        password=os.environ['DB_PASSWORD'],
        database=os.environ['DB_NAME'],
        autocommit=False,
        cursorclass=pymysql.cursors.DictCursor,
        charset='utf8mb4'
    )

def execute_query(query, params=None):
    """ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì•ˆì „í•˜ê²Œ ì‹¤í–‰"""
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute(query, params or ())
            result = cursor.fetchall()
        conn.commit()
        return result
    except Exception as e:
        if conn:
            conn.rollback()
        raise
    finally:
        if conn:
            conn.close()

# PlayerAnalìš© Upsert íŒ¨í„´
def upsert_player_anal(quarter_code, data):
    """PlayerAnal ë°ì´í„° ì‚½ì… ë˜ëŠ” ì—…ë°ì´íŠ¸"""
    conn = get_db_connection()
    try:
        with conn.cursor() as cursor:
            # í…Œì´ë¸” ì»¬ëŸ¼ ê°€ì ¸ì˜¤ê¸°
            cursor.execute("SHOW COLUMNS FROM player_anal")
            valid_cols = {row['Field'] for row in cursor.fetchall()}
            
            # ìœ íš¨í•œ ì»¬ëŸ¼ë§Œ í•„í„°ë§
            filtered_data = {k: v for k, v in data.items() if k in valid_cols}
            filtered_data['quarter_code'] = quarter_code
            
            # SQL êµ¬ì¶•
            cols = list(filtered_data.keys())
            cols_sql = ", ".join(f"`{k}`" for k in cols)
            vals_sql = ", ".join(["%s"] * len(cols))
            upd_sql = ", ".join([f"`{k}`=VALUES(`{k}`)" for k in cols if k != 'quarter_code'])
            
            sql = f"""
                INSERT INTO player_anal ({cols_sql}) 
                VALUES ({vals_sql}) 
                ON DUPLICATE KEY UPDATE {upd_sql}
            """
            
            cursor.execute(sql, [filtered_data[k] for k in cols])
        
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise
    finally:
        conn.close()
```

---

## ğŸŒ S3 í†µí•©

### S3ì—ì„œ ë‹¤ìš´ë¡œë“œ
```python
import boto3

s3 = boto3.client('s3')

def download_gps_data(bucket, key):
    """S3ì—ì„œ /tmpë¡œ GPS ë°ì´í„° ë‹¤ìš´ë¡œë“œ"""
    local_path = f"/tmp/{os.path.basename(key)}"
    
    try:
        s3.download_file(bucket, key, local_path)
        print(f"Downloaded {key} to {local_path}")
        return local_path
    except Exception as e:
        print(f"S3 download failed: {e}")
        raise
```

### S3ì— ê²°ê³¼ ì—…ë¡œë“œ (ì„ íƒì‚¬í•­)
```python
def upload_results_to_s3(data, bucket, key):
    """ë¶„ì„ ê²°ê³¼ë¥¼ S3ì— ì—…ë¡œë“œ"""
    try:
        s3.put_object(
            Bucket=bucket,
            Key=key,
            Body=json.dumps(data),
            ContentType='application/json'
        )
        print(f"Uploaded results to s3://{bucket}/{key}")
    except Exception as e:
        print(f"S3 upload failed: {e}")
        raise
```

---

## ğŸ¤– GPT í†µí•©

### gpt.py íŒ¨í„´
```python
import openai
import os

def call_gpt_api(prompt, max_tokens=500):
    """
    ë¶„ì„ ìš”ì•½ì„ ìœ„í•´ GPT-4 API í˜¸ì¶œ
    
    Args:
        prompt: ë¶„ì„ í”„ë¡¬í”„íŠ¸
        max_tokens: ìµœëŒ€ ì‘ë‹µ í† í°
        
    Returns:
        GPT ì‘ë‹µ í…ìŠ¤íŠ¸
    """
    try:
        openai.api_key = os.environ['GPT_API_KEY']
        
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are a professional sports analyst."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=max_tokens,
            temperature=0.7
        )
        
        return response.choices[0].message.content
        
    except Exception as e:
        print(f"GPT API call failed: {e}")
        raise

def generate_player_summary(quarter_data):
    """í”Œë ˆì´ì–´ ì„±ëŠ¥ì— ëŒ€í•œ AI ìš”ì•½ ìƒì„±"""
    prompt = f"""
    ë‹¤ìŒ ì„ ìˆ˜ ê²½ê¸° ë°ì´í„°ë¥¼ ë¶„ì„í•˜ê³  í•µì‹¬ ì¸ì‚¬ì´íŠ¸ 5ê°€ì§€ë¥¼ ì¶”ì¶œí•˜ì„¸ìš”:
    
    - ì´ ì´ë™ê±°ë¦¬: {quarter_data['T_D']} km
    - í‰ê·  ì†ë ¥: {quarter_data['T_AS']} km/h
    - ìµœê³  ì†ë ¥: {quarter_data['T_HS']} km/h
    - ìŠ¤í”„ë¦°íŠ¸ íšŸìˆ˜: {quarter_data['T_S']}íšŒ
    
    ê° ì¸ì‚¬ì´íŠ¸ëŠ” 40ì ì´ë‚´ë¡œ ì‘ì„±í•˜ì„¸ìš”.
    """
    
    return call_gpt_api(prompt, max_tokens=500)
```

---

## ğŸ“Š CloudWatch ë¡œê¹…

### ë¡œê¹… ëª¨ë²” ì‚¬ë¡€
```python
import json
from datetime import datetime

def log_info(message, **kwargs):
    """CloudWatchìš© êµ¬ì¡°í™”ëœ ë¡œê¹…"""
    log_entry = {
        'timestamp': datetime.utcnow().isoformat(),
        'level': 'INFO',
        'message': message,
        **kwargs
    }
    print(json.dumps(log_entry))

def log_error(message, error, **kwargs):
    """ì»¨í…ìŠ¤íŠ¸ì™€ í•¨ê»˜ ì—ëŸ¬ ë¡œê¹…"""
    log_entry = {
        'timestamp': datetime.utcnow().isoformat(),
        'level': 'ERROR',
        'message': message,
        'error': str(error),
        'traceback': traceback.format_exc(),
        **kwargs
    }
    print(json.dumps(log_entry))

# Lambdaì—ì„œ ì‚¬ìš©
def lambda_handler(event, context):
    log_info("Lambda execution started", event=event)
    
    try:
        # ì²˜ë¦¬
        log_info("Processing match", match_code=match_code)
        
    except Exception as e:
        log_error("Processing failed", error=e, match_code=match_code)
        raise
```

### Lambda ë¡œê·¸ í™•ì¸
```bash
# check_lambda_logs.py ìŠ¤í¬ë¦½íŠ¸ ì‚¬ìš©
cd /home/ubuntu/agrounds/mysite/lambda/player_anal
python3 check_lambda_logs.py

# ë˜ëŠ” AWS CLI ì‚¬ìš©
aws logs tail /aws/lambda/Agrounds_player_anal --follow

# ì—ëŸ¬ë§Œ í•„í„°ë§
aws logs filter-events \
    --log-group-name /aws/lambda/Agrounds_player_anal \
    --filter-pattern "ERROR"
```

---

## âš¡ ì„±ëŠ¥ ìµœì í™”

### ë©”ëª¨ë¦¬ ìµœì í™”
```python
# ëŒ€ìš©ëŸ‰ ë°ì´í„°ì…‹ì— ì œë„ˆë ˆì´í„° ì‚¬ìš©
def process_large_dataset(data):
    """ë©”ëª¨ë¦¬ ì¤„ì´ê¸° ìœ„í•´ ì œë„ˆë ˆì´í„° ì‚¬ìš©"""
    for chunk in pd.read_csv(data, chunksize=10000):
        yield process_chunk(chunk)

# ì‚¬ìš© í›„ ë³€ìˆ˜ ì‚­ì œ
import gc
large_dataframe = process_data()
# ë°ì´í„° ì‚¬ìš©
result = calculate_metrics(large_dataframe)
# ë©”ëª¨ë¦¬ì—ì„œ ì‚­ì œ
del large_dataframe
gc.collect()
```

### íƒ€ì„ì•„ì›ƒ ê´€ë¦¬
```python
import signal

class TimeoutException(Exception):
    pass

def timeout_handler(signum, frame):
    raise TimeoutException("Lambda timeout approaching")

def lambda_handler(event, context):
    """íƒ€ì„ì•„ì›ƒ ë³´í˜¸ê°€ ìˆëŠ” í•¸ë“¤ëŸ¬"""
    # íƒ€ì„ì•„ì›ƒ ì•ŒëŒ ì„¤ì • (ì˜ˆ: Lambda íƒ€ì„ì•„ì›ƒ 10ì´ˆ ì „)
    remaining_time = context.get_remaining_time_in_millis() / 1000
    alarm_time = int(remaining_time - 10)
    
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(alarm_time)
    
    try:
        # ì²˜ë¦¬
        result = long_running_process()
        
    except TimeoutException:
        # íƒ€ì„ì•„ì›ƒ ìš°ì•„í•˜ê²Œ ì²˜ë¦¬
        print("WARNING: Approaching timeout, saving partial results")
        save_partial_results()
        raise
        
    finally:
        signal.alarm(0)  # ì•ŒëŒ ì·¨ì†Œ
```

### ë³‘ë ¬ ì²˜ë¦¬
```python
from concurrent.futures import ThreadPoolExecutor, as_completed

def process_quarters_parallel(quarters):
    """ì—¬ëŸ¬ ì¿¼í„°ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬"""
    results = {}
    
    with ThreadPoolExecutor(max_workers=4) as executor:
        # ì‘ì—… ì œì¶œ
        future_to_quarter = {
            executor.submit(process_quarter, q): q 
            for q in quarters
        }
        
        # ê²°ê³¼ ìˆ˜ì§‘
        for future in as_completed(future_to_quarter):
            quarter = future_to_quarter[future]
            try:
                results[quarter] = future.result()
            except Exception as e:
                print(f"Quarter {quarter} failed: {e}")
    
    return results
```

---

## ğŸ” ì—ëŸ¬ í•¸ë“¤ë§

### Lambda ì—ëŸ¬ ì‘ë‹µ íŒ¨í„´
```python
def lambda_handler(event, context):
    try:
        # ì²˜ë¦¬
        result = process_data(event)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'success': True,
                'data': result
            })
        }
        
    except ValueError as e:
        # í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ (ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥)
        return {
            'statusCode': 400,
            'body': json.dumps({
                'success': False,
                'error': 'INVALID_INPUT',
                'message': str(e)
            })
        }
        
    except ConnectionError as e:
        # ì™¸ë¶€ ì„œë¹„ìŠ¤ ì—ëŸ¬
        return {
            'statusCode': 502,
            'body': json.dumps({
                'success': False,
                'error': 'EXTERNAL_SERVICE_ERROR',
                'message': 'Failed to connect to external service'
            })
        }
        
    except Exception as e:
        # ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬
        print(f"ERROR: {str(e)}")
        print(traceback.format_exc())
        
        return {
            'statusCode': 500,
            'body': json.dumps({
                'success': False,
                'error': 'INTERNAL_ERROR',
                'message': 'Internal processing error'
            })
        }
```

---

## ğŸ§ª Lambda í•¨ìˆ˜ í…ŒìŠ¤íŒ…

### ë¡œì»¬ í…ŒìŠ¤íŒ…
```python
# test_lambda_local.py
import json
from main import lambda_handler

def test_local():
    """Lambdaë¥¼ ë¡œì»¬ì—ì„œ í…ŒìŠ¤íŠ¸"""
    event = {
        "match_code": "m_test123",
        "ground_code": "g_test456",
        "s3_key": "test/gps_data.csv",
        "player_type": "amateur"
    }
    
    # Context Mock
    class MockContext:
        def get_remaining_time_in_millis(self):
            return 300000  # 5ë¶„
    
    context = MockContext()
    
    # ì‹¤í–‰
    result = lambda_handler(event, context)
    
    print(json.dumps(result, indent=2))
    assert result['statusCode'] == 200

if __name__ == '__main__':
    test_local()
```

### AWS CLIë¡œ Lambda í˜¸ì¶œ
```bash
# í…ŒìŠ¤íŠ¸ ì´ë²¤íŠ¸ ìƒì„±
cat > test_event.json << EOF
{
  "match_code": "m_test123",
  "ground_code": "g_test456",
  "s3_key": "test/gps_data.csv"
}
EOF

# Lambda í˜¸ì¶œ
aws lambda invoke \
    --function-name Agrounds_player_anal \
    --payload file://test_event.json \
    --region ap-northeast-2 \
    response.json

# ì‘ë‹µ í™•ì¸
cat response.json
```

---

## ğŸ“Š ëª¨ë‹ˆí„°ë§ & ë””ë²„ê¹…

### CloudWatch ë©”íŠ¸ë¦­
ë‹¤ìŒ ë©”íŠ¸ë¦­ ëª¨ë‹ˆí„°ë§:
- **Invocations** - ì´ Lambda ì‹¤í–‰ íšŸìˆ˜
- **Duration** - ì‹¤í–‰ ì‹œê°„ (ëª©í‘œ: < 120ì´ˆ)
- **Errors** - ì‹¤íŒ¨í•œ ì‹¤í–‰
- **Throttles** - Rate limit ë„ë‹¬
- **Concurrent Executions** - ë³‘ë ¬ ì‹¤í–‰

### CloudWatch ì•ŒëŒ
ë‹¤ìŒì— ëŒ€í•œ ì•ŒëŒ ì„¤ì •:
- ì—ëŸ¬ìœ¨ > 5%
- ì‹¤í–‰ ì‹œê°„ > 240ì´ˆ (íƒ€ì„ì•„ì›ƒì˜ 80%)
- Throttles > 0
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ > 90%

### ë””ë²„ê¹… íŒ
```python
# ìƒì„¸ ë¡œê¹… ì¶”ê°€
def process_quarter(quarter_data):
    print(f"[DEBUG] Processing quarter: {quarter_data['quarter_code']}")
    print(f"[DEBUG] Data points: {len(quarter_data['gps_points'])}")
    
    start_time = time.time()
    result = calculate_metrics(quarter_data)
    duration = time.time() - start_time
    
    print(f"[DEBUG] Processing completed in {duration:.2f}s")
    return result

# ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¡œê¹…
import psutil
import os

def log_memory_usage():
    """í˜„ì¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¡œê¹…"""
    process = psutil.Process(os.getpid())
    memory_mb = process.memory_info().rss / 1024 / 1024
    print(f"[MEMORY] Current usage: {memory_mb:.2f} MB")
```

---

## âœ… Lambda ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë°°í¬ ì „
- [ ] í™˜ê²½ ë³€ìˆ˜ ì„¤ì •ë¨
- [ ] íƒ€ì„ì•„ì›ƒ ì ì ˆíˆ ì„¤ì • (player_analì€ 300ì´ˆ)
- [ ] ë©”ëª¨ë¦¬ í• ë‹¹ (1024 MB ê¶Œì¥)
- [ ] Lambda layers ì—°ê²°ë¨
- [ ] IAM ê¶Œí•œ ë¶€ì—¬ (S3, RDS, CloudWatch)
- [ ] ì—ëŸ¬ í•¸ë“¤ë§ êµ¬í˜„ë¨
- [ ] CloudWatch ë¡œê¹… ì¶”ê°€ë¨
- [ ] /tmp ì •ë¦¬ êµ¬í˜„ë¨
- [ ] ë¡œì»¬ í…ŒìŠ¤íŠ¸ ì™„ë£Œ
- [ ] ì˜ì¡´ì„±ì„ layerì— (ZIPì— í¬í•¨ ì•ˆ í•¨)

### ë°°í¬ í›„
- [ ] ì‹¤ì œ ë°ì´í„°ë¡œ í…ŒìŠ¤íŠ¸
- [ ] CloudWatch ë¡œê·¸ í™•ì¸
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸ ê²€ì¦
- [ ] ì‹¤í–‰ ì‹œê°„ ëª¨ë‹ˆí„°ë§
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
- [ ] CloudWatch ì•ŒëŒ ì„¤ì •
- [ ] ì´ìŠˆ ë¬¸ì„œí™”
- [ ] í•„ìš”ì‹œ README ì—…ë°ì´íŠ¸

### ì½”ë“œ í’ˆì§ˆ
- [ ] í•˜ë“œì½”ë”©ëœ ìê²©ì¦ëª… ì—†ìŒ
- [ ] ì ì ˆí•œ ì˜ˆì™¸ ì²˜ë¦¬
- [ ] êµ¬ì¡°í™”ëœ ë¡œê¹… (JSON í˜•ì‹)
- [ ] ì…ë ¥ ê²€ì¦
- [ ] ì¶œë ¥ ê²€ì¦
- [ ] ë©±ë“±ì„± ì‘ì—… (ì¬ì‹œë„ ì•ˆì „)
- [ ] ë¬´í•œ ë£¨í”„ ì—†ìŒ
- [ ] finally ë¸”ë¡ì—ì„œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬

---

## ğŸ”— ê´€ë ¨ ê°€ì´ë“œë¼ì¸

**í•¨ê»˜ ì°¸ì¡°:**
- `general/error-handling.mdc` - ì—ëŸ¬ í•¸ë“¤ë§ íŒ¨í„´
- `general/security.mdc` - ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€
- `database/patterns.mdc` - ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—…
- `backend/api-development.mdc` - Django API í†µí•©

**ì™¸ë¶€ ë¦¬ì†ŒìŠ¤:**
- [AWS Lambda Developer Guide](https://docs.aws.amazon.com/lambda/)
- [Lambda Best Practices](https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html)
- [CloudWatch Logs](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/)

---

**ê¸°ì–µí•˜ì„¸ìš”: Lambda í•¨ìˆ˜ëŠ” ë¬´ìƒíƒœ, ë©±ë“±ì„±, ë¹ ë¥¸ ì‹¤í–‰ì— ìµœì í™”ë˜ì–´ì•¼ í•©ë‹ˆë‹¤!**
